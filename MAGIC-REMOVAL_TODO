# Next up
* Keep going with actually using the returned client object in operations

# Once basic functionality has been restored
* See all TODO markings in source code
* Take a step back, reorganize. E.g.:
    * stuff in `utils` should be user-useful only, other subroutines ought to go
    elsewhere
    * Should probably move subroutines in `main` to another module so that
    `main` is just that: `main()`. New module would be something like `core` -
    subroutines of the same sort found in `utils` but NOT usually for user
    consumption (and ALSO not generally used multiple times by internals? or
    should this be the same spot as other non-user-facing subroutines?)
* Continue building out any previously made tests till coverage.py implies we
have pretty decent coverage (100% would be nice but even a 100% from coverage.py
doesn't literally mean full coverage...)
    * Have started using Nose for testing, probably stick with that;
    * Ditto with Fudge for mocking/stubbing/expecting; may need to contribute
    some patches to it, though, it's not great for functional coding and I
    don't see the need to 100% class-ify my code just so my mocker works better.
* Sphinx documentation (though this requires going back to RST...)
* Run Pylint, fix what it complains about (and generate a config file to make it
shut up about stuff I don't care about)
* Make sure "constants" are consistently named: I've been trending towards not
  using ALL_CAPS, but in some places I probably did use them, so check and
  update (or change my mind and go back; but it just feels ugly when one is
  referencing e.g. ENV in user code all over...)
* Possibly note in docs that callables imported into one's fabfile will show up
  as executable tasks; i.e. they'll clutter --list and can be invoked via
  command-line.
    * If we do note this for users, probably suggest the obvious: import
    modules instead of callables, and use module.callable instead.
    * Also good to note that they can take *advantage* of this to make
    "meta-fabfiles" collecting a number of sub-fabfiles' tasks into one
    user-facing presentation.
        * Although, with flags for manually specifying 1+ sub-fabfiles at
        runtime, that becomes less necessary, though still useful.
* Start a 'lib' type thing with non-atomic builtin commands, e.g. `sudo_put`.
Figure out how best to accomplish this: where should it live? what's the most
idiomatic way to present it to users?
    * Could borrow a page from Django and call it `contrib`
    * Or, if all previously builtin "commands" are now option flags, we could
    simply have `commands`, which makes it obvious that they are on the same
    level as user-defined commands.
* Terminology: rename 'commands' to 'tasks', 'operations' to 'commands' or
'functions' or something?
    * Plus: 'tasks' and etc sounds more natural to me; given how big of a
    shake-up this is, why not go whole hog?
    * Minus: commands/operations aren't all that bad for names, and should
    avoid tendency to redo everything for redoing's sake.
    * Minus: 'commands' feels like the most natural fit for a rename of
    'operations' -- but then it's pretty confusing given the previous use of
    'commands'!
* Add Paramiko SSHConfig support: it can provide username and port and other
options. Look at `man ssh_config` for what else people can put in that file.

<!-- vim:set filetype=mkd : -->
