#!/usr/bin/env python

# Fabric - Pythonic remote deployment tool.
# Copyright (C) 2008  Christian Vest Hansen
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

import getpass
import sys
import os
import os.path
import types
import re
import threading
import time
import random

try:
    import paramiko as ssh
except ImportError:
    print("ERROR: paramiko is a required module. Please install it.")
    exit(1)

__version__ = '0.0.1'
__author__ = 'Christian Vest Hansen'
__license__ = '''\
   Fabric v. %(fab_version)s, Copyright (C) 2008 %(fab_author)s.
   Fabric comes with ABSOLUTELY NO WARRANTY; for details type `fab warranty'.
   This is free software, and you are welcome to redistribute it
   under certain conditions; type `fab license' for details.
'''

ENV = {
    'fab_version':__version__,
    'fab_author':__author__,
    'fab_mode':'fanout',
    'fab_port':22,
    'fab_user':None,
    'fab_password':None,
    'fab_pkey':None,
    'fab_key_filename':None,
    'fab_new_host_key':'accept'
}
COMMANDS = {} # populated by load() and _load_std_commands()
CONNECTIONS = []

#
# Standard fabfile operations:
#
def set(**variables):
    "Set a number of Fabric environment variables."
    for k, v in variables.items():
        if isinstance(v, types.StringTypes):
            ENV[k] = (v % ENV)
        else:
            ENV[k] = v

def get(name):
    "Get the value of a given Fabric environment variable."
    return ENV[name]

def require(var, **kvargs):
    "Make sure that a certain environmet variable is available."
    if var in ENV:
        return
    print(
        ("The '%(fab_cur_command)s' requires a '" + var + "' variable.") % ENV
    )
    if 'used_for' in kvargs:
        print("This variable is used for %s" % kvargs['used_for'])
    if 'provided_by' in kvargs:
        print("Get the variable by running one of these commands:")
        print('\t' + ('\n\t'.join(kvargs['provided_by'])))

def put(localpath, remotepath, **kvargs):
    "Upload a file to the current hosts."
    if not CONNECTIONS: _connect()
    _on_hosts_do(_put, localpath, remotepath)

def run(cmd, **kvargs):
    "Run a shell command on the current hosts."
    if not CONNECTIONS: _connect()
    _on_hosts_do(_run, cmd)

def sudo(cmd, **kvargs):
    "Run a sudo (root privileged) command on the current hosts."
    if not CONNECTIONS: _connect()
    _on_hosts_do(_sudo, cmd)

def local(cmd, **kvargs):
    "Run a command locally."
    os.system(cmd)

def local_per_host(cmd, **kvargs):
    "Run a command locally, for every defined host."
    _check_fab_hosts()
    for host in ENV['fab_hosts']:
        ENV['fab_host'] = host
        cur_cmd = _lazy_format(cmd)
        os.system(cur_cmd)

def load(filename, **kvargs):
    "Load up the given fabfile."
    execfile(filename)
    for name, obj in locals().items():
        if not name.startswith('_') and isinstance(obj, types.FunctionType):
            COMMANDS[name] = obj

def upload_project(**kvargs):
    "Uploads the current project directory to the connected hosts."
    r = random.randint(100000, 999999)
    tar_file = "/tmp/fab.%d.tar" % r
    cwd_name = os.getcwd().split(os.sep)[-1]
    local("tar -czf %s ." % tar_file)
    put(tar_file, cwd_name + ".tar.gz")
    local("rm -f " + tar_file)
    run("tar -xzf " + cwd_name)
    run("rm -f " + cwd_name + ".tar.gz")

#
# Standard Fabric commands:
#
def _help(command=None):
    "Display usage help message to the console, or help for a given command."
    if command is not None and command in COMMANDS:
        print(COMMANDS[command].__doc__)

def _list():
    "Display a list of commands with descriptions."
    max_name_len = reduce(lambda a,b: max(a, len(b)), COMMANDS.keys(), 0)
    print("Available commands are:")
    cmds = COMMANDS.items()
    cmds.sort(lambda x,y: cmp(x[0], y[0]))
    for name, fn in cmds:
        print '  ', name.ljust(max_name_len), ':', fn.__doc__.splitlines()[0]

def _license():
    "Display the Fabric distribution license text."
    pass

def _warranty():
    "Display warranty information for the Fabric software."
    pass

def _set(arg):
    """Set a Fabric variable.
    
    Example:
        $fab set:fab_user=billy,other_var=other_value
    """
    vars = arg.split(',')
    for var in vars:
        k, v = var.split('=', 1)
        ENV[k] = (v % ENV)

#
# Internal plumbing:
#
def _pick_fabfile():
    "Figure out what the fabfile is called."
    choise = 'fabfile'
    alternatives = ['Fabfile', 'fabfile.py', 'Fabfile.py']
    for alternative in alternatives:
        if os.path.exists(alternative):
            choise = alternative
            break
    return choise

def _load_std_commands():
    "Loads up the standard commands such as help, list, warranty and license."
    global COMMANDS
    COMMANDS['help'] = _help
    COMMANDS['list'] = _list
    COMMANDS['warranty'] = _warranty
    COMMANDS['license'] = _license
    COMMANDS['set'] = _set

def _check_fab_hosts():
    "Check that we have a fab_hosts variable, and complain if it's missing."
    if 'fab_hosts' not in ENV:
        print("Fabric requires a fab_hosts variable.")
        print("Please set it in your fabfile.")
        print("Example: set(fab_hosts=['node1.com', 'node2.com'])")
        exit(1)

def _connect():
    "Populate CONNECTIONS with (hostname, client) tuples as per fab_hosts."
    _check_fab_hosts()
    ENV['fab_password'] = getpass.getpass()
    port = int(ENV['fab_port'])
    username = ENV['fab_user']
    password = ENV['fab_password']
    pkey = ENV['fab_pkey']
    key_filename = ENV['fab_key_filename']
    for host in ENV['fab_hosts']:
        client = ssh.SSHClient()
        client.load_system_host_keys()
        if 'fab_new_host_key' in ENV and ENV['fab_new_host_key'] == 'accept':
            client.set_missing_host_key_policy(ssh.AutoAddPolicy())
        client.connect(
            host, port, username, password, pkey, key_filename
        )
        CONNECTIONS.append((host, client))
    if not CONNECTIONS:
        print("The fab_hosts list was empty.")
        print("Please specify some hosts to connect to.")
        exit(1)

def _disconnect():
    "Disconnect all clients."
    for host, client in CONNECTIONS:
        client.close()

def _lazy_format(string):
    "Do string substitution of ENV vars - both lazy and earger."
    suber = re.compile(r'\$\((?P<var>\w+?)\)')
    string = string % ENV # early earger
    string = re.sub(suber, lambda m: ENV[m.group('var')], string) # lazy part
    string = string % ENV # late earger
    return string

def _on_hosts_do(fn, *args):
    """Invoke the given function with hostname and client parameters in
    accord with the current fac_mode strategy.
    
    fn should be of type:
        (str:hostname, paramiko.SSHClient:clinet) -> bool:success
    
    """
    strategy = ENV['fab_mode']
    if strategy == 'fanout':
        threads = []
        for host, client in CONNECTIONS:
            ENV['fab_host'] = host
            thread = threading.Thread(None, lambda: fn(host, client, *args))
            thread.setDaemon(True)
            thread.start()
            threads.append(thread)
        for thread in threads:
            thread.join()
    elif strategy == 'rolling':
        for host, client in CONNECTIONS:
            ENV['fab_host'] = host
            fn(host, client, *args)
    else:
        print("Unsupported fab_mode: %s" % strategy)
        print("Supported modes are: fanout, rolling")
        exit(1)

def _put(host, client, localpath, remotepath):
    ftp = client.open_sftp()
    localpath = _lazy_format(localpath)
    remotepath = _lazy_format(remotepath)
    print("[%s] put: %s -> %s" % (host, localpath, remotepath))
    ftp.put(localpath, remotepath)

def _run(host, client, cmd):
    cmd = _lazy_format(cmd)
    print("[%s] run: %s" % (host, cmd))
    stdin, stdout, stderr = client.exec_command(cmd)
    out_th = _start_outputter("[%s] out" % host, stdout)
    err_th = _start_outputter("[%s] err" % host, stderr)
    out_th.join()
    err_th.join()

def _sudo(host, client, cmd):
    cmd = _lazy_format(cmd)
    print("[%s] sudo: %s" % (host, cmd))
    stdin, stdout, stderr = client.exec_command("sudo -S " + cmd)
    stdin.write(ENV['fab_password'])
    stdin.write('\n')
    stdin.flush()
    out_th = _start_outputter("[%s] out" % host, stdout)
    err_th = _start_outputter("[%s] err" % host, stderr)
    out_th.join()
    err_th.join()

def _start_outputter(prefix, channel):
    def outputter():
        line = channel.readline()
        while line:
            print("%s: %s" % (prefix, line)),
            line = channel.readline()
    thread = threading.Thread(None, outputter, prefix)
    thread.setDaemon(True)
    thread.start()
    return thread

def main(args):
    print(__license__ % ENV)
    _load_std_commands()
    fabfile = _pick_fabfile()
    load(fabfile)
    # validation:
    for cmd in args:
        if cmd.find(':') != -1:
            cmd = cmd.split(':', 1)[0]
        if not cmd in COMMANDS:
            print("No such command: %s" % cmd)
            _list()
            exit(1)
    # execution:
    if not args:
        print("No commands given.")
        _list()
    for cmd in args:
        cmd_name = cmd
        cmd_args = None
        if cmd.find(':') != -1:
            cmd_name, cmd_args = cmd.split(':', 1)
        ENV['fab_cur_command'] = cmd_name
        print('Running %s...' % cmd)
        if cmd_args is not None:
            COMMANDS[cmd_name](cmd_args)
        else:
            COMMANDS[cmd]()
    print('Done.')

if __name__ == '__main__':
    try:
        try:
            main(sys.argv[1:])
        finally:
            _disconnect()
    except SystemExit:
        # a number of internal functions might raise this one.
        raise
    except:
        sys.excepthook(*sys.exc_info())
        # we might leave stale threads if we don't explicitly exit()
        exit(1)
    exit(0)
